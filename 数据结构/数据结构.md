数据结构

------

[迭代与递归](https://blog.csdn.net/weixin_47716438/article/details/117171458)

## 绪论

1. 逻辑结构: 前驱,指向该节点的指针节点,后继,该节点指向的下一个节点<a,.b>a是b的前驱,b是a的后继-表示方式(二元偶对)

   1. 线性结构: 每个节点有一个前驱和一个后继 

      > S={<ai,ai+1>| i=1,2,3,4,5} a[1]为初始节点,a[5]为终止节点

   2. (非线性结构)

      1. 树形结构: 有一个前驱和n个后继

   3. 图形结构

      1. 复杂结构:有n个前驱和n个后继

2. 存储结构:

   1. 顺序:数据一定要挨着存放
   2. 链表:数据可以分散但必须有指针链接不同数据
   3. 散列:有数据得到函数与地址相关联,从而快速找到
   4. 索引:类似二叉树,将数据与地址捆绑

5. 时间复杂度(程序执行(运算)的次数)

   > T(n)
   >
   > 常数阶执行时间与n无关O(1)
   >
   > 线性阶 O(n)
   >
   > <img src="C:\Users\李禹佳\AppData\Roaming\Typora\typora-user-images\image-20230228152839505.png" alt="image-20230228152839505" style="zoom: 50%;" />

   

6. 空间复杂度(临时占用的储存空间)

   > S(n)
   >
   > 只增加常量-(eg.int i;) 表示为 O(1)

## 线性表

<img src="C:\Users\李禹佳\AppData\Roaming\Typora\typora-user-images\image-20230302174636968.png" alt="image-20230302174636968" style="zoom:67%;" />

> 不可以不申请空间直接直接给指针赋值
>
> 抽象数据类型: ADT 
>
> 写法:
>
> ```c
> List list;
> DataType x;
> Position p;
> ```
>
> <img src="C:\Users\李禹佳\AppData\Roaming\Typora\typora-user-images\image-20230302171708177.png" alt="image-20230302171708177" style="zoom:67%;" />
>
> ```c++
> #define MaxSize 20;//线性表的最大容量
> typdef struct node{
>     DataType *element;//元素类型(不同),替代普通结构体中 int data;位置
>     int length;//线性表长度
> }SQlist;
> SQlist* InitList(){
>     SQlist* palist=(SQlist*)malloc(sizeof(SQlist));
>     if(palist!-NULL){
>         palist->element=(DataType*)malloc(sizeof(DataType));
> }
> }
> ```
>
> 

### ==顺序表==

> 注意:
>
> 1. 判断线性表是否存在
>
>    ```c
>    myList != NULL ? 1:0;
>    ```
>
> 2. 判断线性表是否为空
>
>    ```c
>    L->curNum!=0 ? 1:0
>    ```
>
> 3. 判断线性表是否已满
>
>    ```c
>    L->curNum >= L->MAXNUM ? 1 : 0
>    ```
>
> 4. 输入地址非法
>
>    ```c
>    pos<0||pos>=MAXINUM ? 1 : 0
>    ```
>
>    

1. 构建顺序表

   ```c
   /*此处是顺序线性表数据结构定义*/
   typedef int DataType;
   struct seqList {
   	/* MAXINUM 只用于存放最大元素个数的值*/
   	int MAXNUM;
       /* curNum 数组现在的长度,初始值为0*/
   	int curNum;
       /* element 为一个数组,顺序表相当于一个大数组*/
   	DataType *element;
   };
   
   typedef struct seqList *PseqList;
   ```

   或者  (不确定最大值↑)   (确定最大值↓)

   ```c
   typedef int DataType;
   #define MAXINUM 100
   struct seqList{
       /* curNum 数组现在的长度,初始值为0*/
       int curNum;
       /* element 为一个数组,顺序表相当于一个大数组*/
       DataType *element;
   };
   
   typedef struct seqList *PseqList;
   ```

   

2. 创建空顺序线性表,能存放的最大元素个数为 m

   ```c
   PseqList createNullList_seq(int m) {
       /*若m=0，则返回NULL*/
   	if (m == 0) return NULL;
       
       /*创建一个空的顺序线性表，能存放的最大元素个数为 m*/
   	PseqList myList = (PseqList)malloc(sizeof(struct seqList));
   	if (myList != NULL) {
   		myList->element = (DataType*)malloc(m * sizeof(DataType));//m
   		if (myList->element) {
   			myList->MAXNUM = m;
   			myList->curNum = 0;
   			return myList;
   		}
   		free(myList);
   	}
   	return NULL;
   }
   ```

3. 判断顺序表是否已满

   ```c
   int isFullList_seq(PseqList L) {
   	//判断顺序线性表是否已满，若已满，返回值为1，否则返回值为0
   	return L->curNum >= L->MAXNUM ? 1 : 0;
   }
   ```
   
3. 判断顺序表是否插入非法

   ```c
   int isIllegal (PseqList L, int p) {
   	//如果插入位置非法,返回1,否则返回0; 
   	if (p < 0 || p > L->curNum) return 1;
   	else return 0;
   }
   ```
   
3. 在线性表L中下标为p的位置插入数据元素x

   ```c
   int insertP_seq(PseqList L, int p, int x) {
       int i;
       
   	//如果线性表满了
   		if (isFullList_seq(L)) {
   		printf("list is full");
   		return 0;
   	}
       
       //如果插入位置非法
   		if (isIllegal(L, p)) {
   		printf("position is illegel");
   		return 0;
   	}
      
       // 在线性表L中下标为p的位置插入数据元素x,插入成功返回值为1
   	for (i = L->curNum - 1; i >= p; i--) {
   		L->element[i + 1] = L->element[i];
   	}
   	L->element[p] = x;
   	L->curNum = L->curNum + 1;
   	return 1;
   }
   
   int insertPre_seq(PseqList L, int p, int x) {
   // 在线性表L中下标为p的位置的前面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
   	return (insertP_seq(L, p - 1, x));
   }
   
   int insertPost_seq(PseqList L, int p, int x) {
   // 在线性表L中下标为p的位置的后面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
   	return (insertP_seq(L, p + 1, x));
   }
   ```
   
4. 逐个输出线性表的元素

   ```c
   void printList_seq(PseqList L) {
   	//逐个输出线性表的元素，相邻的两个数据元素之间以一个空格为分隔符隔开
   	int i;
   	for (i = 0; i < L->curNum; i++)
   		printf("%d ", L->element[i]);
   }
   ```

5. 返回线性表中现有数据元素的个数

   ```c
   int destroyList_seq(PseqList L) {
   	//返回值为销毁的线性表中现有数据元素的个数，若待销毁的线性表不存在，则返回0
   	int i = 0;
   	if (L == NULL) return 0;
   	else  for (i = 0; i < L->curNum; i++) {}
   	return i;
   }
   ```

6. 在顺序表L中查找给定值x首次出现的位置

   ```c
   int locate_seq(PseqList L, int x) {
   	//在顺序表L中查找给定值x首次出现的位置，若不存在给定值，则返回-1
   	for (int i = 0; i < L->curNum; i++)
   		if (L->element[i] == x) return i;
   	return -1;
   }
   ```

7. 在顺序表L中查找指定位置pos处的数据元素

   ```c
   DataType locatePos_seq(PseqList L, int pos) {
   	// 在顺序表L中查找指定位置pos处的数据元素，若位置非法，则返回第0个数据元素
   	if (pos < 0 || pos >= L->curNum) return L->element[0];
   	else return L->element[pos];
   }
   ```

8. 在顺序表L中删除与下标pos处的数据元素

   ```c
   int deletePos_seq(PseqList L, int pos) {
   	//在顺序表L中删除与下标pos处的数据元素，若pos非法，则返回-1；否则返回1
   	if (pos < 0 || pos > L->curNum - 1) return -1;
   	for (int i = pos; i < L->curNum - 1; i++)
   		L->element[i] = L->element[i + 1];
   	L->curNum--;
   	return 1;
   }
   ```

9. 在顺序表L中删除与参数x值相同的数据元素

   ```c
   int delete_seq(PseqList L, int x) {
   	//在顺序表L中删除与参数x值相同的数据元素，返回删除数据元素的个数
   	//可以使用之前已完成的操作
   	int i, j;
   	for (i = 0, j = 0; i < L->curNum; i++) {
   		if (L->element[i] != x) {
   
   			L->element[j] = L->element[i];
   			j++;
   		}
   	}
   	L->curNum = j;
   	return i - j - 1;
   }
   ```

10. 将顺序表L中值为x的数据元素替换为y

    ```c
    void replace_seq(PseqList L, int x, int y) {
    	//将顺序表L中值为x的数据元素替换为y
    	for (int i = 0; i < L->curNum; i++) {
    		if (L->element[i] == x) {
    			L->element[i] = y;
    		}
    	}
    }
    ```

11. 移除线性表中的所有重复元素

    ```c
    void delDuplicate_seq(PseqList L) {
    	//移除线性表中的所有重复元素；不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成
    	for (int i = 0; i < L->curNum; i++) {
    		int t = i;
    		bool haveRETURN = false;
    		for (int j = i + 1; j < L->curNum; j++) {
    			if (L->element[i] == L->element[j]) {
    				deletePos_seq(L, j);
    				haveRETURN = true;
    			}
    		}
    		if (haveRETURN) {
    			deletePos_seq(L, t);
    		}
    	}
    }
    ```

12. 源代码

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    /*此处是顺序线性表数据结构定义*/
    typedef int DataType;
    struct seqList {
    	//有3个数据成员
    	int MAXNUM;//用于记录顺序线性表中能存放的最大元素个数的 整型 MAXNUM
    	int curNum;//用于存放顺序线性表中数据元素的个数  整型  curNum
    	DataType *element;//用于存放顺序线性表数据元素的连续空间的起始地址
    };
    
    typedef struct seqList *PseqList;
    //第一关
    PseqList createNullList_seq(int m) {
    	//此处填写代码，创建一个空的顺序线性表，能存放的最大元素个数为 m
    //若m=0，则返回NULL
    	if (m == 0) return NULL;
    	PseqList myList = (PseqList)malloc(sizeof(struct seqList));
    	if (myList != NULL) {
    		myList->element = (DataType*)malloc(m * sizeof(DataType));
    		if (myList->element) {
    			myList->MAXNUM = m;
    			myList->curNum = 0;
    			return myList;
    		}
    		free(myList);
    	}
    	printf("Out of sapce!!\n");
    	return NULL;
    }
    
    //第二关
    int isFullList_seq(PseqList L) {
    	//判断顺序线性表是否已满，若已满，返回值为1，否则返回值为0
    	return L->curNum >= L->MAXNUM ? 1 : 0;
    }
    
    
    int insertP_seq(PseqList L, int p, int x) {
    	// 在线性表L中下标为p的位置插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
    	//如果线性表满了， 还需输"list is full"的提示
    	//如果插入位置非法，需输出提示"position is illegel"
    	int i;
    	if (L->curNum == L->MAXNUM) {
    		printf("list is full");
    		return 0;
    	}
    	if (p < 0 || p > L->curNum) {
    		printf("position is illegel");
    		return 0;
    	}
    	for (i = L->curNum - 1; i >= p; i--) {
    		L->element[i + 1] = L->element[i];
    	}
    	L->element[p] = x;
    	L->curNum = L->curNum + 1;
    	return 1;
    }
    
    int insertPre_seq(PseqList L, int p, int x) {
    // 在线性表L中下标为p的位置的前面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
    //提示：直接调用insertP函数实现即可
    	insertP_seq(L, p - 1, x);
    
    }
    
    int insertPost_seq(PseqList L, int p, int x) {
    // 在线性表L中下标为p的位置的后面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
    //提示：直接调用insertP函数实现即可
    	insertP_seq(L, p + 1, x);
    
    }
    
    void printList_seq(PseqList L) {
    	//逐个输出线性表的元素，相邻的两个数据元素之间以一个空格为分隔符隔开
    	int i;
    	for (i = 0; i < L->curNum; i++)
    		printf("%d ", L->element[i]);
    }
    
    //第三关
    int destroyList_seq(PseqList L) {
    	//返回值为销毁的线性表中现有数据元素的个数，若待销毁的线性表不存在，则返回0
    	int i = 0;
    	if (L == NULL) return 0;
    	else  for (i = 0; i < L->curNum; i++) {}
    	return i;
    }
    
    //第四关
    int locate_seq(PseqList L, int x) {
    	//在顺序表L中查找给定值x首次出现的位置，若不存在给定值，则返回-1
    	for (int i = 0; i < L->curNum; i++)
    		if (L->element[i] == x) return i;
    	return -1;
    }
    
    DataType locatePos_seq(PseqList L, int pos) {
    	// 在顺序表L中查找指定位置pos处的数据元素，若位置非法，则返回第0个数据元素
    	if (pos < 0 || pos >= L->curNum) return L->element[0];
    	else return L->element[pos];
    }
    
    //第五关
    int deletePos_seq(PseqList L, int pos) {
    	//在顺序表L中删除与下标pos处的数据元素，若pos非法，则返回-1；否则返回1
    	if (pos < 0 || pos > L->curNum - 1) return -1;
    	for (int i = pos; i < L->curNum - 1; i++)
    		L->element[i] = L->element[i + 1];
    	L->curNum--;
    	return 1;
    }
    
    int delete_seq(PseqList L, int x) {
    	//在顺序表L中删除与参数x值相同的数据元素，返回删除数据元素的个数
    	//可以使用之前已完成的操作
    	int i, j;
    	for (i = 0, j = 0; i < L->curNum; i++) {
    		if (L->element[i] != x) {
    
    			L->element[j] = L->element[i];
    			j++;
    		}
    	}
    	L->curNum = j;
    	return i - j - 1;
    }
    
    
    //第六关
    void replace_seq(PseqList L, int x, int y) {
    	//将顺序表L中值为x的数据元素替换为y
    	for (int i = 0; i < L->curNum; i++) {
    		if (L->element[i] == x) {
    			L->element[i] = y;
    		}
    	}
    }
    
    void delDuplicate_seq(PseqList L) {
    	//移除线性表中的所有重复元素；不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成
    	for (int i = 0; i < L->curNum; i++) {
    		int t = i;
    		bool haveRETURN = false;
    		for (int j = i + 1; j < L->curNum; j++) {
    			if (L->element[i] == L->element[j]) {
    				deletePos_seq(L, j);
    				haveRETURN = true;
    			}
    		}
    		if (haveRETURN) {
    			deletePos_seq(L, t);
    		}
    	}
    }
    ```

13. 移动节点次数的期望值

    <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202303212019365.png" alt="image-20230321201900271" style="zoom:50%;" />

### ==连接表==

> 纯链表,用指针将节点链接起来

1. 构建连接表

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   struct node {
   	/*存放整型数据*/
   	int data;
   	struct node *next;
   };
   typedef node *Node;
   ```

   

2. 创建空链表

   ```c
   Node mycreateList() {
   	//创建一个只有一个头结点的空链表，头节点的数据域赋值为0，并将表头结点的地址返回
   	Node head = (Node)malloc(sizeof(node));
   	if (head != NULL) head->next = NULL;
   	return head;
   }
   ```

   

3. 插入元素-头插法

   ```c
   void myinsertHead(struct node * head, int insData ) {
   	/*插入元素-头插法*/
   	Node p = (Node)malloc(sizeof(node));
   	p->next = head->next;
   	head->next = p;
   	p->data = insData;
   }
   ```

4. ==插入元素-尾插法==

   ```c
   void myinsertTail(Node head, int insData ) {
   	/*插入元素-尾插法*/
   	Node p, s = (Node)malloc(sizeof(node));
   	p = head;
   	while (p->next != NULL)
   		p = p->next;
   	s->data = insData;
   	s->next = NULL;
   	p->next = s;
   }
   ```

5. 输出链表

   ```c
   void myprintList(Node L) {
   	/*输出表*/
   	Node p;
   	p = L;
   	for (; p->next != NULL;) {
   		p = p->next;
   		printf("%d\n", p->data);
   	}
   }
   ```

6. ==链表逆置==

   ```c
   void reverseList_link(Node L) {
   	//链表逆置
   	Node p, s;
   	p = L->next;
   	L->next = NULL;
   	while (p) {
   		s = p;
   		p = p->next;
   		s->next = L->next;
   		L->next = s;
   	}
   }
   ```

7. 查找元素

   ```c
   FindElement(Node L, int data) {
   	/*find element*/
   	Node p;
   	p = L;
   	for (;;) {
   		if (p->data == data) 
   			return 1;
   		p=p->next;
   	}
   	return 0;
   }
   ```

8. 求表长

   ```c
   int destroyList(Node L) {
   	//求表长 
   	Node p;
   	p = L;
   	int i;
   	for (i = 0; p->next != NULL; i++) {
   		p = p->next;
   	}
   	return i + 1;
   }
   ```

### ==队列***==

> 先进先出: 
>
> 进栈: 第一个进栈的在首位,第二个在第一个后面依次排下去
>
> 出栈: 从第一个进栈的开始向外出栈
>
> 队尾进队首出

1. 定义

   ```c
   #include <stdio.h>
   #include<string.h>
   #include<stdlib.h>
   /*此处是顺序队列数据结构定义*/
   typedef int DataType;
   struct seqQueue { //请完成数据结构定义
   	int MAXINUM;
   	int front, rear;//从0开始
   	DataType *q;
   };
   ```

   

2. 创建空队列

   ```c
   typedef struct seqQueue *PseqQueue;
   //第一关
   PseqQueue createNullQueue_seq(int m) {
   	//此处填写代码，创建一个空的顺序队列，能存放的最大元素个数为 m
   	//若m=0，则返回NULL
   	if (m == 0) return NULL;
   	PseqQueue palist = (PseqQueue)malloc(sizeof(struct seqQueue));
   	if (palist != NULL) {
   		palist->q = (DataType*)malloc(sizeof(DataType) * m);
   		if (palist->q) {
   			palist->MAXINUM = m;
   			palist->front = 0;
   			palist->rear = 0;
   			return palist;
   		} else free(palist);
   	}
   	return NULL;
   }
   ```

   

3. 判断是否为空

     

   ```c
   //第二关
   int isNullQueue_seq(PseqQueue Q) {
   	//判断顺序（环形）队列是否为空，若为空，返回值为1，否则返回值为0,若队列不存在，则返回-1
   	if (Q->front == Q->rear) return 1;
   	else if (Q == NULL) return -1;
   	else return 0;
   }
   ```

   

4. 判断是否已满

   ```c
   //第三关
   int isFullQueue_seq(PseqQueue Q) {
   	//判断环形队列是否已满，若已满，返回值为1，否则返回值为0
   	if ((Q->rear + 1) % (Q->MAXINUM) == Q->front) return 1;
   	return 0;
   }
   ```

   

5. 插入数据

   ```c
   //第四关
   int enQueue_seq(PseqQueue Q, DataType x) {
   	//在环形队列中插入数据元素x，若插入不成功，返回0；插入成功返回值为1
   	int q = isFullQueue_seq(Q);
   	if (!q) {
   		Q->q[Q->rear] = x;
   		Q->rear = (Q->rear + 1) % (Q->MAXINUM);//队尾插入,队尾加一
   		return 1;
   	} else return 0;
   }
   ```

   

6. 出队并删除数据

   ```c
   //第五关
   DataType delQueue_seq(PseqQueue Q) {
   	//出队并返回删除元素，若队列为空，则返回-1
   	if (Q->front == Q->rear) return -1;
   	else {
   		int m = Q->q[Q->front];
   		Q->front = (Q->front + 1) % (Q->MAXINUM);//队首出,队首加一
   		return m;
   	}
   }
   ```

   

7. 取首地址

   ```c
   //第六关
   DataType front_seq(PseqQueue Q) {
   	// 取队首元素返回，若队列为空，则返回-1
   	if (Q->front == Q->rear) return -1;
   	else return Q->q[Q->front];
   }
   ```

   

8. 销毁数据队列,释放空间

   ```c
   //销毁顺序队列，释放队列所占存储空间
   int destroyQueue_seq(PseqQueue Q) {
   	//返回值为销毁的栈中现有数据元素的个数，若待销毁的线性表不存在，则返回0
   	if (Q == NULL) return 0;
   	else {
   		int num = Q->front + 1;
   		Q->MAXINUM = 0;
   		free(Q->q);
   		return num;
   	}
   }
   ```

   

9. 例题

    <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202303252048224.png" alt="image-20230325204810169" style="zoom:80%;" />

   ```c
   //第七关
   void queueApp(int a[], int n) {
   //参数用于传递顾客编号和顾客人数，输出顾客接受服务后离开顺序
   	PseqQueue q1 = createNullQueue_seq(n + 1);
   	PseqQueue q2 = createNullQueue_seq(n + 1);
   	for (int i = 0; i < n; i++) {
   		if (a[i] % 2 == 0) enQueue_seq(q1, a[i]);
   		else enQueue_seq(q2, a[i]);
   	}
       
   	while (!isNullQueue_seq(q1) && !isNullQueue_seq(q2)) {
   		//q1与q2皆为非空 
   		printf("%d ", delQueue_seq(q2));
   		printf("%d ", delQueue_seq(q2));
   		printf("%d ", delQueue_seq(q1));
   	}
   	while (!isNullQueue_seq(q1)) {
   		printf("%d ", delQueue_seq(q1));
   	}
   	while (!isNullQueue_seq(q2)) {
   		printf("%d ", delQueue_seq(q2));
   	}
   }
   ```

   



### ==栈==

> 先进后出
>
> 进栈: 第一个进栈的在首位,第二个在第一个后面依次排下去
>
> 出栈: 最后一个进栈的最先出栈
>
> 队尾进队尾出

1. 顺序栈定义

   ```c
   #include <stdio.h>
   #include<string.h>
   #include<stdlib.h>
   /*此处是顺序栈数据结构定义*/
   typedef int DataType;
   struct seqStack {
   	//有3个数据成员
   	int MAXNUM;//用于记录顺序栈中能存放的最大元素个数的 整型 MAXNUM
   	int top;//用于存放顺序栈的栈顶位置，初始化为0或-1 均可  整型  curNum
   	DataType *element;//用于存放顺序栈数据元素的连续空间的起始地址
   };
   ```

   

2. 创建空顺序栈

   ```c
   typedef struct seqStack *PseqStack;
   //第一关
   PseqStack createNullStack_seq(int m) {
   	//此处填写代码，创建一个空的顺序栈，能存放的最大元素个数为 m,栈顶top设置为0
   	//若m=0，则返回NULL
   	if (m == 0) return NULL;
   	PseqStack palist = (PseqStack)malloc(sizeof(struct seqStack));
   	if (palist != NULL) {
   		palist->element = (DataType*)malloc(sizeof(DataType) * m);
   		if (palist->element) {
   			palist->MAXNUM = m;
   			palist->top = 0;
   			return palist;
   		} else free(palist);
   	}
   	return NULL;
   }
   ```

   

3. 判断栈是否为空

   ```c
   //第二关
   int isNullStack_seq(PseqStack L) {
   	//判断顺序栈是否为空，若为空，返回值为1，否则返回值为0,若栈不存在，则返回-1
   	if (L == NULL) return -1;
   	else {
   		if (L->top == 0) return 1;
   		else return 0;
   	}
   }
   ```

   

4. 判断栈是否已满

   ```c
   //第三关
   int isFullStack_seq(PseqStack L) {
   	//判断顺序栈是否已满，若已满，返回值为1，否则返回值为0
   	if (L->top == L->MAXNUM) return 1;
   	return 0;
   }
   ```

   

5. 插入元素

   ```c
   //第四关
   int push_seq(PseqStack L, DataType x) {
   	//在顺序栈中插入数据元素x，若插入不成功，返回0；插入成功返回值为1
   	if (isFullStack_seq(L)) return 0;
   	L->top = L->top + 1;
   	L->element[L->top] = x;
   	return 1;
   }
   ```

   

6. 弹栈

   ```c
   //第五关
   DataType pop_seq(PseqStack L) {
   	//弹栈并返回删除元素，若栈为空，则返回-1
   	if (isNullStack_seq(L) == 1) return -1;
   	int m = L->element[L->top];
   	L->top = L->top - 1;
   	return m;
   }
   ```

   

7. 返回数据元素个数

   ```c
   //第六关
   DataType top_seq(PseqStack L) {
   	// 取栈顶元素返回，若栈为空，则返回-1
   	if (isNullStack_seq(L)) return -1;
   	return (L->element[L->top]);
   }
   
   //销毁顺序栈，释放栈所占存储空间
   int destroystack_seq(PseqStack L) {
   	//返回值为销毁的栈中现有数据元素的个数，若待销毁的线性表不存在，则返回0
   	if (L) return 0;
   	int m = L->top;
   	free(L->element);
   	return m;
   }
   ```

   

8. 练习

   ```c
   //第七关
   //使用已实现的栈操作，实现数制转换
   
   void print(PseqStack L) {
   	//逐个弹出栈L中的数据元素并输出，输出数据间不需要任何间隔符号
   	while (!isNullStack_seq(L))
   		printf("%d", pop_seq(L));
   
   }
   
   void convert(int data, int k) {
       //利用栈实现将data转换为k进制，k可能是2，8，16. 在本函数内实现转换并调用print函数输出转换后的结果
       //十六进制时输出 A ,B ,C, D,E,F 使用大写字母
       int m=data;
       PseqStack head = createNullStack_seq(10);
       while(m){
   		push_seq(head,m%k);
   		m/=k;
   	}
   	if(k==2||k==8) print(head);
   	else{
   		while(!isNullStack_seq(head)){
   			if(head->element[head->top]>=10) printf("%c",head->element[head->top]+55);
   			else printf("%d",head->element[head->top]);
   			pop_seq(head);
   		}
   	}
   }
   ```

   

## 二叉树

+ 二叉树相关概念

  + 兄弟(在同一根节点的左右节点成为兄弟)

  + 路径(从根节点(最上面的)到子节点(最下面的,没有子节点的)的过程)

  + 层数(根的层数为0)

  + 度数(节点所具有的子节点数)

  + 高度(最大层数,从下向上)

    > 空二叉树的高度为-1
    >
    > 只有一个节点的二叉树高度为0

  + 深度(最大层数,从上到下)

+ 二叉树的分类

  + 满二叉树(只要有子节点,则一定同时具有左右节点)
  + 完全二叉树叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
  + 扩充二叉树(将所有没有满足节点度数为2的节点补上,新增节点用长方形表示)

+ 二叉树的性质

  + 高度为k的二叉数中,最多有2^k+1^-1个节点                 
  + 高度为h(根高度为0)的二叉树上只有度为0和2的节点,则此类二叉树中所包含的结点数只少为 2h+1
  + 具有n个节点的完全二叉树的高度k为 log~2~n

+ 节点与子节点

  + 叶节点数=度数为2的节点数+1
  + 在满二叉树中叶节点个数比分支结点个数多1
  + 扩充二叉树中,外部结点的个数比内部结点的个数多1
  + 已知完全二叉树第n层有m个节点,求叶子节点数
    + 第n-1层有2^n-1^个节点
    + 第n层m个节点的父节点有m/2个
    + 所以叶子节点数为 (第n层节点数) + (第n-1层节点数) - (第n层m个节点的父节点数)
    + n +2^n-1^ - m/2 

+ 周游

  + 深度优先周游

    <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021419290.png" alt="image-20230402141936247" style="zoom:50%;" />

    + 先根次序(先访问根,再按先根次序周游左子树,最后按先根次序周游右子树)

      上图为 ABDCEGFHI

      ```c
      #include <iostream>
      using namespace std;
      
      typedef char DataType;
      
      //二叉树数据结构 
      struct node
      {
      	DataType info ; //存放结点数据 
      	node *lchild , *rchild ; //指向左右孩子的指针 
      };
      
      typedef node *BiTree ;
      
      /*创建二叉树
        函数名：createBiTree
        参数：无
        返回值：二叉树根结点指针
        */
      BiTree createBiTree(void)
      {
          char c;
          BiTree root;
          scanf("%c",&c);
          if(c=='#') root=NULL;
          else{
      		root=new struct node;
               root=(BiTree)malloc(sizeof(node));
      		root->info=c;
      		root->lchild=createBiTree();
      		root->rchild=createBiTree();
      	}
      	return root;
      }
      
      void visit(BiTree T) //输出结点T的数据
      {
      	cout<<T->info ;
      }
      
      //递归算法
      
      void preOrder(BiTree t){
      	if(!t) return;
      	visit(t);
      	preOrder(t->lchild);
      	preOrder(t->rchild);
      }
      ```

      

    + 中根次序(先按中根次序周游左子树,然后访问根,最后按中根次序访问右子树)

      上图为DBAEGCHFI

      ```c
      #include <iostream>
      using namespace std;
      
      typedef char DataType;
      
      //二叉树数据结构 
      struct node
      {
      	DataType info ; //存放结点数据 
      	struct node *lchild , *rchild ; //指向左右孩子的指针 
      };
      
      typedef struct node *BiTree ;
      
      /*创建二叉树
        函数名：createBiTree
        参数：无
        返回值：二叉树根结点指针
        */
      BiTree createBiTree(void)
      {
          char c;
          BiTree root;
          scanf("%c",&c);
          if(c=='#') root=NULL;
          else{
      		root=new struct node;
      		root->info=c;
      		root->lchild=createBiTree();
      		root->rchild=createBiTree();
      	}
      	return root;
      }
      
      void visit(BiTree T) //输出结点T的数据
      {
      	cout<<T->info ;
      }
      
      //递归算法
       
      void inOrder(BiTree t){
      	if(!t) return;
      	inOrder(t->lchild);
      	visit(t);
      	inOrder(t->rchild);
      }
      ```

      

    + 后跟次序(先按后跟次序周游左子树,然后按后跟次序周游右子树,最后访问根)

      上图为DBGEHIFCA

      ```c
      #include <iostream>
      using namespace std;
      
      typedef char DataType;
      
      //二叉树数据结构 
      struct node
      {
      	DataType info ; //存放结点数据 
      	struct node *lchild , *rchild ; //指向左右孩子的指针 
      };
      
      typedef struct node *BiTree ;
      
      /*创建二叉树
        函数名：createBiTree
        参数：无
        返回值：二叉树根结点指针
        */
      BiTree createBiTree(void)
      {
          char c;
          BiTree root;
          scanf("%c",&c);
          if(c=='#') root=NULL;
          else{
      		root=new struct node;
      		root->info=c;
      		root->lchild=createBiTree();
      		root->rchild=createBiTree();
      	}
      	return root;
      }
      
      void visit(BiTree T) //输出结点T的数据
      {
      	cout<<T->info ;
      }
      
      //递归算法
       
      void postOrder(BiTree t){
      	if(!t) return;
      	postOrder(t->lchild);
      	postOrder(t->rchild);
      	visit(t);
      }
      ```

      

  + 广度优先周游(从根节点(第0层)开始向下逐层周游)

    上图为ABCDEFGHI

  + 通过某两个顺序来推出整个二叉树

    + 先序序列 + 中序序列

      eg. 先序: ABDGCEFH     中序: DGBAECHF

      1.  先排好根(root)节点

         在先序序列中,第一个字母为根(即root)节点,为A

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021538931.png" alt="image-20230402153839888" style="zoom:50%;" />

      2. 寻找根的子节点(以左子树为例)

         由①可知,中序序列以根节点为分界线,左子树有元素(D,G,B) 右子树有元素(E,C,H,F)

         由先序序列定义可知,第二个元素为根节点的左子节点(第五个元素为根节点的右子节点)

         B为A的左子节点

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021539014.png" alt="image-20230402153931976" style="zoom:50%;" />

      3. 推导

         由②可知,中序左子数有元素(D,G,B)

         由先序序列,第三个元素为D,中序序列中该元素在B的前面,又中序序列左子节点在根节点的前面

         D为B的左子节点

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021540041.png" alt="image-20230402154018999" style="zoom:50%;" />

      4. 推导

         由②可知,中序左子数有元素(D,G,B)

         由先序序列,第四个元素为G,中序序列中该元素在B的前面,又中序序列右子节点在根节点的后面

         G不为B的右子节点

         中序序列中该元素在D的后面,又中序序列右子节点在根的后面

         G为D的右子节点

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021541976.png" alt="image-20230402154113937" style="zoom:50%;" />

      5. 同理可推导出右子树

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021544159.png" alt="image-20230402154450122" style="zoom:80%;" />

    + 中序序列 + 后序序列

      eg. 中序: GDHBEAFIC	后序: GHDEBIFCA

      1. 寻找根(root)节点

         在后序序列中,最后一个元素为根(即root)节点

         A为根节点

      2. 推导根节点的左子节点(以左子树为例)

         由①可知,中序序列以根节点为分界线,左子树有元素(G,D,H,B,E) 右子树有元素(F,I,C)

         后序序列,左子树(G,H,D,E,B) 右子树(I,F,C)

         由后序序列定义可知,左子树中元素的最后一个B为根节点的左子节点

         B为根节点的左子节点

      3. 推导

         继承②

         由后序序列定义可知,从左子树元素的最后一个向前推

         E在中序序列中B的后面,又中序序列中右子节点在根节点的后面

         E为B的右子节点

      4. 推导

         继承③

         D在中序序列中B的前面,又中序序列中左子节点在根节点的前面

         D为B的右子节点

      5. 推导

         继承④

         H在中序序列中D的后面

         H为D的右子节点

      6. 推导

         继承④

         G在中序序列中D的前面

         G为D的左子节点

      7. 同理可推出右子树

         <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202304021613393.png" alt="image-20230402161352352" style="zoom:80%;" />

    + 先序序列和后序序列推不出来完整的二叉树

  + 探究某两个序列之间的关系

    + 先序序列 = 后序序列 
      1. 二叉树空或只有一个节点
    + 先序序列与后序序列相反
      1. 当且仅当二叉树中只有一个叶子节点
      2. 二叉树的高度和其节点个数相同
    + 先序序列 = 中序序列 
      1. 空树或缺左子树的单支二叉树
    + 先序序列与中序序列相反 
      1. 二叉树为空或者只有一个节点
      2. 若二叉树不为空，则任意节点不能同时用于左子节点和右子节点
      3. 若二叉树不为空，则任意节点没有右子节点
    + 中序序列 = 后序序列
      1. 空树或者缺右子树的单支二叉树
    + 中序序列和后序序列相反
      1. 任意节点没有左子节点

+ 

1. 二叉树以及二叉树的创建

   ```c
   #include <iostream>
   using namespace std;
   
   typedef char DataType;
   
   //二叉树数据结构 
   struct node
   {
   	DataType info ; //存放结点数据 
   	struct node *lchild , *rchild ; //指向左右孩子的指针 
   };
   
   typedef struct node *BiTree ;
   
   /*创建二叉树
     函数名：createBiTree
     参数：无
     返回值：二叉树根结点指针
     */
   BiTree createBiTree(void)
   {
   	//请在此处填写代码， 完成二叉树和创建，返回值是二叉树的根结点指针
       /********** Begin **********/
       char c;
       BiTree root;
       scanf("%c",&c);
       if(c=='#') root=NULL;
       else{
   		root=new struct node;
   		root->info=c;
   		root->lchild=createBiTree();
   		root->rchild=createBiTree();
   	}
   	return root;
       /********** End *********/
   }
   
   void visit(BiTree T) //输出结点T的数据
   {
   	cout<<T->info ;
   }
   
   void inOrder(BiTree root)
   {
   	if(root == NULL) return ;
   	inOrder(root->lchild);
   	visit(root);
   	inOrder(root->rchild);
   }
   
   int main(void)
   {
   	BiTree root = createBiTree();
   	inOrder(root);
   }
   ```

2. 计算二叉树中树叶的个数

   ```c
   #include <iostream>
   using namespace std;
   
   typedef char DataType;
   
   //二叉树数据结构 
   struct node
   {
   	DataType info ; //存放结点数据 
   	struct node *lchild , *rchild ; //指向左右孩子的指针 
   };
   
   typedef struct node *BiTree ;
   
   /*创建二叉树
     函数名：createBiTree
     参数：无
     返回值：二叉树根结点指针
     */
   BiTree createBiTree(void)
   {
   	char ch ;
   	BiTree  root ;
   	cin>>ch ;
   	if(ch == '#') root = NULL;
   	else{
           root = new struct node ;
           root->info = ch ;
           root->lchild = createBiTree() ;
           root->rchild = createBiTree();
   	}
   	return root ;
   }
   
   void visit(BiTree T)
   {
   	cout<<T->info ;
   }
   
   int countLeaf(BiTree root)
   {
       //请在此处填写代码， 计算二叉树中树叶的个数
       /********** Begin **********/
       if(!root) return 0;
       else if (!root->lchild&&!root->rchild) return 1;
       else return (countLeaf(root->lchild)+countLeaf(root->rchild));
       /********** End **********/
   }
   
   int main(void)
   {
   	BiTree root = createBiTree();
   	cout<<countLeaf(root);
   }
   ```

   

3. 二叉树左右子树互换 

   ```c
   #include <iostream>
   using namespace std;
   
   typedef char DataType;
   
   //二叉树数据结构 
   struct node
   {
   	DataType info ; //存放结点数据 
   	struct node *lchild , *rchild ; //指向左右孩子的指针 
   };
   
   typedef struct node *BiTree ;
   
   /*创建二叉树
     函数名：createBiTree
     参数：无
     返回值：二叉树根结点指针
     */
   BiTree createBiTree(void)
   {
   	char ch ;
   	BiTree  root ;
   	cin>>ch ;
   	if(ch == '#') root = NULL;
   	else{
           root = new struct node ;
           root->info = ch ;
           root->lchild = createBiTree() ;
           root->rchild = createBiTree();
   	}
   	return root ;
   }
   
   void changeLR(BiTree root)
   {
   	//请在此处填写代码， 完成二叉树左右子树互换 
       /********** Begin **********/
       
       //递归算法
       
       if(!root) return;
       else{
   		BiTree change=root->lchild;
   		root->lchild=root->rchild;
   		root->rchild=change;
   		changeLR(root->lchild);
   		changeLR(root->rchild);
   	}
       
       //非递归算法
       
       void Change(BiTree root)
   {
       BiTree Queue[MAXSIZE];
       int front=-1;
       int rear=0;
       Queue[rear]=root;
       while(rear!=front)
       {
           BiTree p=Queue[++front];
           BiTree temp=p->lchild;
           p->lchild=p->rchild;
           p->rchild=temp;
           if(p->lchild) Queue[++rear]=p->lchild;
           if(p->rchild) Queue[++rear]=p->rchild;
       }
   }
   
       /********** End **********/
   }
   
   void visit(BiTree T) //输出结点T的数据
   {
   	cout<<T->info ;
   }
   
   void inOrder(BiTree root)
   {
   	if(root == NULL) return ;
   	inOrder(root->lchild);
   	visit(root);
   	inOrder(root->rchild);
   }
   
   int main(void)
   {
   	BiTree root = createBiTree();
       changeLR(root);
   	inOrder(root);
   }
   ```

   

4. 计算二叉树中满节点的个数

   ```c
   #include <iostream>
   using namespace std;
   
   typedef char DataType;
   
   //二叉树数据结构 
   struct node
   {
   	DataType info ; //存放结点数据 
   	struct node *lchild , *rchild ; //指向左右孩子的指针 
   };
   
   typedef struct node *BiTree ;
   
   /*创建二叉树
     函数名：createBiTree
     参数：无
     返回值：二叉树根结点指针
     */
   BiTree createBiTree(void)
   {
   	char ch ;
   	BiTree  root ;
   	cin>>ch ;
   	if(ch == '#') root = NULL;
   	else{
           root = new struct node ;
           root->info = ch ;
           root->lchild = createBiTree() ;
           root->rchild = createBiTree();
   	}
   	return root ;
   }
   
   void visit(BiTree T)
   {
   	cout<<T->info ;
   }
   
   int countFullNode(BiTree root)
   {
   	//请在此处填写代码，计算二叉树中满结点的个数
       /********** Begin **********/
       if(!root) return 0;
       if(root->lchild&&root->rchild) return countFullNode(root->lchild)+countFullNode(root->rchild)+1;
       /*********** End-**********/
   }
   
   int main(void)
   {
   	BiTree root = createBiTree();
   	cout<<countFullNode(root) ;
   }
   ```

   

5. 

### ==哈夫曼树==

1. 权值与哈夫曼树

   给定权值总数有N个，则其哈夫曼树的结点总数为2*N-1

   给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

   哈夫曼树只有叶子结点和度为2的结点，无度为1的结点。在只含度为2和叶子结点的树中度为2的结点数是叶子-1。权值点度为0的点n，则度为2的结点数为n-1

2. 哈夫曼树与频率

   eg. 6 1 2 4 17 15 21 10 

   1. 每次都取两个最小值

   2. 将两个最小值的加和放入元素中

   3. 创建树

   4. 当根不为最小值之一时重新建立子树至根为最小值

      | 6 1 2 4 17 15 21 10 | 1 2   |
      | ------------------- | ----- |
      | 6 3 4 17 15 21 10   | 3 4   |
      | 6 7 17 15 21 10     | 6 7   |
      | 13 17 15 21 10      | 10 13 |
      | 23 17 15 21         | 15 17 |
      | 23 32 21            | 23 21 |
      | 32 44               | 32 44 |
      | 76                  |       |

      <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301726214.png" alt="image-20230530172634922" style="zoom:50%;" />

   5. 哈夫曼树的哈夫曼编码

   6. 左0右1

   7. huff man 编码从上至下

      A: 1110

      B: 111100

      C: 111101 

      D: 11111
      E: 01

      F: 00

      G: 10

      H: 110

3. 将森林转化为二叉树

   + 树->二叉树
   + 连接根

   1. 树->二叉树

      + 将根的兄弟之间连线
      + 只保留最左边的连线

      <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301747430.png" alt="image-20230530174734162" style="zoom:50%;" />

      <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301747410.png" alt="image-20230530174755180" style="zoom:50%;" />

      将其他的树也化为二叉树

      <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301748374.png" alt="image-20230530174832155" style="zoom:50%;" />

      <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301748298.png" alt="image-20230530174850140" style="zoom:50%;" /><img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301749669.png" alt="image-20230530174900584" style="zoom:50%;" />

   2. 将多个二叉树相连

   + 将每个根通过右子节点相连

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301750381.png" alt="image-20230530175028923" style="zoom: 50%;" />

   得到结果

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301751612.png" alt="image-20230530175106351" style="zoom:50%;" />

4. 

## 集合与字典

### ==二叉排序树==

eg.{7,3,10,12,5,1,8,2}

排序顺序不变

+ 以第一个数为根节点
+ 将小的数放在大的数的有右侧

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301803440.png" alt="image-20230530180344274" style="zoom: 80%;" />

平均查找长度: 

成功ASL: (1/(元素个数))(比较次数相加)

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301808087.png" alt="image-20230530180837974" style="zoom:67%;" />

ASL=(1/8)(1+2 *2+3 *4+4)

失败ASL:(1/失败点)(比较次数相加)

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301816444.png" alt="image-20230530181609942" style="zoom: 67%;" />

ASL=(1/9)(3 *7+4 *2)

### ==最佳二叉排序树==

eg.{7,3,10,12,5,1,8,2}

先排序

{1,2,3,5,7,8,10,12}

1. 选中间元素作为根(偶数偏左)
2. 选中间偏左的中间值作为左子根,中间偏右的中间值作为右子根

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301823240.png" alt="image-20230530182318130" style="zoom:67%;" />

成功ASL=(1/8)(1+2 *2+3 *4+4)

失败ASL=(1/9)(3 *7+4 *2)

### ==线性探测==

eg. 有关键字序列{47 7 29 11 16 92 22 8 3} 散列函数h(key)=key mod 11;

h(47) = 3

h(7) = 7

h(29) = 7

h(11) = 0

h(16) = 5

h(92) = 4

h(22) = 0

h(8) = 8

h(3) = 3

将关键字放入下表,如果位置被占则向后找第一个空位放入

如下图所示

| 散列地址 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键码   | 11   | 22   |      | 3    | 47   | 16   | 92   | 7    | 8    | 29   |      |

成功的ASL: 每个关键字的探测次数相加除以关键字的个数

探测次数: eg.11,探测次数为1,22探测次数为2,等等

| 散列地址       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键码         | 11   | 22   |      | 3    | 47   | 16   | 92   | 7    | 8    | 29   |      |
| 关键码探测次数 | 1    | 2    | 0    | 1    | 2    | 1    | 3    | 1    | 1    | 3    | 0    |

失败的ASL: 到空处的比较次数相加除以医工所占位数(模-1)

比较次数: eg. 11 比较次数为3,22比较次数为2,等等



| 散列地址 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键码   | 11   | 22   |      | 3    | 47   | 16   | 92   | 7    | 8    | 29   |      |
| 比较次数 | 3    | 2    | 1    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    |

[指路](https://blog.csdn.net/u011080472/article/details/51177412)

### ==链地址法(拉链法)==

0-11-22-^
1-^
2-^
3-3-47-^
4-92-^
5-16-^
6-^
7-7-29-^
8-8-^
9-^
10-^

成功的ASL: 竖着看, 第一列是11 3 92 16 7 8,第二列是22 47 29	((第一列)1*(个数)6 + (第二列)2 *(个数)3...(一直加加到全为空为止))/(元素个数)9

失败的ASL: 横着看,第一行有2个数(不算空^),第二行没有数...	(2+2+1+1+2+1)/(位置个数,即模-1)11

[指路](https://www.cnblogs.com/wangzheming35/p/13562735.html)

## 图

### 最小生成树的构造

#### ==prim==

从2开始

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301832099.png" alt="image-20230530183207968" style="zoom:67%;" />

| 2           | 1 3 4 5 6 | 2-1 2-3 2-5√         |
| ----------- | --------- | -------------------- |
| 2 5         | 1 3 4 6   | 2-1 2-3√ 5-3 5-6     |
| 2 3 5       | 1 4 6     | 2-1 5-6 3-1√ 3-4 3-6 |
| 1 2 3 5     | 4 6       | 5-6 3-4 3-6√ 1-4     |
| 1 2 3 5 6   | 4         | 3-4 1-4 6-4√         |
| 1 2 3 4 5 6 |           |                      |

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301838345.png" alt="image-20230530183807213" style="zoom: 67%;" />

#### ==kruaskal==

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301838374.png" alt="image-20230530183842266" style="zoom:67%;" />

+ 选最短边
+ 不能形成回路

| 1-2 1-3 1-4 2-3 2-5 3-4 3-5 3-6 4-6 5-6 | 1-3  |
| --------------------------------------- | ---- |
| 1-2 1-4 2-3 2-5 3-4 3-5 3-6 4-6 5-6     | 4-6  |
| 1-2 1-4 2-3 2-5 3-4 3-5 3-6 5-6         | 2-5  |
| 1-2 1-4 2-3 3-4 3-5 3-6 5-6             | 3-6  |
| 1-2 2-3 3-5 5-6                         | 2-3  |

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301846029.png" alt="image-20230530184622902" style="zoom:67%;" />

### 最短路径

#### ==Dijikastra==

<img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305301851138.png" alt="image-20230530185112999" style="zoom:67%;" />

|      S      |     U     |     LENGTH      |     PREVEX     |
| :---------: | :-------: | :-------------: | :------------: |
|             |           |   A B C D E F   |  A B C D E F   |
|      A      | B C D E F |  0 ∞ 4√28 ∞ ∞   | A -1 A A -1 -1 |
|     A C     |  B D E F  | 0 19 4 28 ∞ 12√ |  A C A A -1 C  |
|    A C F    |   B D E   | 0 19√4 25 30 12 |  A C A F F C   |
|   A B C F   |    D E    | 0 19 4 25√29 12 |  A C A F B C   |
|  A B C D F  |     E     | 0 19 4 25 29√12 |  A C A F B C   |
| A B C D E F |           | 0 19 4 25 29 12 |  A C A F B C   |

| A->B | A->C->B    | 19   |
| ---- | ---------- | ---- |
| A->C | A->C       | 4    |
| A->D | A->C->F->D | 25   |
| A->E | A->C->B->E | 29   |
| A->F | A->C->F    | 12   |



1. 无向图的邻接矩阵一定是对称的,有向图的邻接矩阵可以不对称

2. 最短路径:

   + Dijskra算法: 

     + 无向图: 

       1. 将权值表示在邻接矩阵中,其中所有在主对角线上的(从自己到自己的)都赋为0,有连通的值的将该点赋为权值,没有连通的将该点赋为无穷大.

       2. 初始化两个数组,一个用来记录权值的变更(moon),一个用来记录每次走到的点(record)

       3. 每进行一次时都要找变更数组中的最小值来成为下一个的点,将找到的这个点在记录点的数组(record)中赋值为0

       4. 递归,得到对每个顶点的最短路径

          ```c
          DMap* Dijkastra(int n, DMap *map) {
          	int min = 0, minn = 0;
          	for (int i = 0; i < n; i++) {
          		if (map->record[i] != 0) {
          			min = map->record[i];
          			minn = i;
          			break;
          		}
          	}
          	//找record数组中第一个非0的值赋为min的初始值,minn标记位置
          
          	for (int i = 1; i < n; i++)//
          		if (map->record[i] != 0)
          			if (min > map->record[i]) {
          				min = map->record[i];
          				minn = i;
          			}
          	map->record[minn] = 0;
          	//找到不为0的record数组中最小的那个数,将record数组的那个值记为0
          
          	for (int i = 0; i < n; i++)
          		if (map->record[i] != 0)
          			if (map->moon[minn] + graph[minn][i] < map->moon[i]){
          				map->moon[i] = map->moon[minn] + graph[minn][i];
                            map->record[i]=map->moon[i];
                      }
          	//更新权值
          
          	int m = 0;
          	for (int i = 0; i < n; i++) {
          		if (map->record[i] != 0) {
          			m = 1;
          			break;
          		}
          	}
          	if (m == 0) return map;
          	//如果moon数组都为0,跳出
          
          	Dijkastra(n, map);//递归
          }
          ```

          

   + 

3. 邻接矩阵

   [邻接矩阵和邻接表时间复杂度](https://blog.csdn.net/fu_jian_ping/article/details/89300415)

4. 连通图 

   [在I个具有n个顶点的有向图中，构成强连通图时至少有()条边。](https://www.nowcoder.com/questionTerminal/4269ae44fb094cf388bbc24b5d8f6342)

   [.如果从无向图的任 顶点出发进行次广度优先遍历即可访问所有顶点，则该图一定是(](https://www.nowcoder.com/questionTerminal/f3872e433c1f4700b0fa01e133d301d7?source=relative)

   [对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是( )。](https://www.nowcoder.com/questionTerminal/1859060d9b674cd5972cd829793f7043)

   

5. 

## 排序

### ==时间复杂度==

1. 步长为1

2. 步长不止1

   ```c
   for(int i=0;i<n;i+=2){}
   ```

   2^x^ <n 

   O(log~2~^n^)

3. 双重循环 (只考虑数量级)

   ```c
   for(int i=0;i<n;i++){//步长为1 
       for(int j=0;j<i;j++){//步长为1 
       }
   }
   ```

   (n-1)(1+n-1)/2

   O(n^2^)

4. 等差数列

   ```c
   while(s<=n){
       i++;
       s=s+i;
   }
   ```

   x(x+1)/2 <=n

   O(n^1/2^)

5. 

### ==排序==

以对下面关键字{25,39,64,12,98,6,7}进行一趟排序后的结果（升序）为例

1. 冒泡排序

   大数向下沉

   邻接的两个数小的在前大的在后(有重合数)

   25 39 12 64 6 7 98

2. 直接排序

   每次都将最小的数放在最前面

   6 39 64 12 98 25 7

3. 希尔排序

   增量为总长度/2

   第一个数为0

   每一个数都与之增量为(总长度/2)的数相比

   例如: 总长度为8

   第一趟:

   则增量为4

   第一个数0与第五个数4相比较

   第二个数1与第六个数5相比较

   ...

   第四个数与第八个数相比较

   第二趟:

   增量为3

   0Vs3

   1Vs4

   2Vs5

   3Vs6

   4Vs7

   5Vs8

   第三趟:

   增量为2

   0Vs2

   1Vs3

   2Vs4

   3Vs5

   4Vs6

   5Vs7

   6Vs8

   第四趟:

   ...

   例如:

   总长度为7

   则增量为3

   ...

   7 39 6 12 98 64 25

4. 快速排序

   从后往前找最小的,从前往后找最大的

   以第一个数为基准

   eg.25,39,64,12,98,6,7

   第一趟:

   以25为基准

   | 7    |      |      |      |      |      | 39   |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 7    | 6    |      |      |      | 64   | 39   |
   | 7    | 6    | 12   |      | 98   | 64   | 39   |
   | 7    | 6    | 12   | 25   | 98   | 64   | 39   |

   第二趟:

   以7为基准

   | 6    |      | 12   |
   | ---- | ---- | ---- |
   | 6    | 7    | 12   |

   以98为基准

   | 39   |      |      |
   | ---- | ---- | ---- |
   | 39   | 64   |      |
   | 39   | 64   | 98   |

   | 6    | 7    | 12   | 25   | 39   | 64   | 98   |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

5. 二路归并

   两两比较(数据不重合)

   25 39 12 64 6 98 7

6. 直接插入排序

   以第一个为基准,将下一个数据放在这个元素的左右侧

   25 39 64 12 98 6 7

7. 基数排序

   第一趟: 个位

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   |      |      | 12   |      | 64   | 25   | 6    | 7    | 98   | 39   |

   第二趟:十位

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 6,7  | 12   | 25   | 39   |      |      | 64   |      |      | 98   |

8. 堆排序

   建立完全二叉树

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305302114649.png" alt="image-20230530211429575" style="zoom:67%;" />

   根据 根>左子节点,右子节点

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305302117136.png" alt="image-20230530211704091" style="zoom:67%;" />

   得到初始堆

   第一趟: 将根与最后一个节点交换

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305302119897.png" alt="image-20230530211944854" style="zoom:67%;" />

   使堆平衡

   <img src="https://daimaxiaofeiwu.oss-cn-guangzhou.aliyuncs.com/img/202305302122861.png" alt="image-20230530212237788" style="zoom:67%;" />

   第二趟: 将根与倒数第二个节点交换...
